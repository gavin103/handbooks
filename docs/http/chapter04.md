---
title: 第四章：连接管理
date: 2021-01-11
---

[[TOC]]

HTTP 连 接是 HTTP 报文传输的关键通道。
本章内容包含以下部分：
- HTTP 是如何使用 TCP 连接的;
- TCP 连接的时延、瓶颈以及存在的障碍;
- HTTP 的优化，包括并行连接、keep-alive(持久连接)和管道化连接; 
- 管理连接时应该以及不应该做的事情。

## 4.1 TCP连接

### 4.1.1 TCP的可靠数据管道

TCP 为 HTTP 提供了一条可靠的比特传输管道。
从 TCP 连接一端填入的字节会从另 一端以原有的顺序、正确地传送出来。
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eef94231d1548c2ba53a8b3a38b9b52~tplv-k3u1fbpfcp-watermark.image)

### 4.1.2 TCP流是分段的、由IP分组传送

TCP 的数据是通过名为 IP 分组(或 IP 数据报)的小数据块来发送的。
HTTP 就是“HTTP over TCP over IP”这个“协议栈”中的最顶层 了。
其安全版本 HTTPS 就是在 HTTP 和 TCP 之间插入了一个(称为 TLS 或 SSL 的)密码加密层
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f62c05a7085e46b3829b03b4d624a3a4~tplv-k3u1fbpfcp-watermark.image)

HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。
TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输。
所有这些工作都是由 TCP/ IP 软件来处理的，HTTP 程序员什么都看不到。

每个 IP 分组中都包括:
- 一个IP分组首部(通常为20字节)，IP 首部包含了源和目的 IP 地址、长度和其他一些标记。
- 一个 TCP 段首部(通常为 20 字节)，TCP 段的首部包含了 TCP 端口号、TCP 控制标记，以及用于数据排序和完整性检查的一些数字值。
- 一个 TCP 数据块(0 个或多个字节)。

在任意时刻计算机都可以有几条 TCP 连接处于打开状态。TCP 是通过端口号来保持所有这些连接持续不断地运行。
端口号和雇员使用的电话分机号很类似。就像公司的总机号码能将你接到前台，而 分机号可以将你接到正确的雇员位置一样，IP 地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去。TCP 连接是通过 4 个值来识别的:
```< 源 IP 地址、源端口号、目的 IP 地址、目的端口号 >```
这 4 个值一起唯一地定义了一条连接。
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69c4c57dcd3e4d3b94736c07d859f3f9~tplv-k3u1fbpfcp-watermark.image)

下图显示了 Web 浏览器是如何用 HTTP 从 Joe 的五金商店下载 power-tools.html 页面的。
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db978d79df484735a553e112cc768dd5~tplv-k3u1fbpfcp-watermark.image)

## 4.2 对TCP性能的考虑

### 4.2.1 HTTP事务的时延

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93e0bcc011a74efea9306a1034a96f43~tplv-k3u1fbpfcp-watermark.image)
上图为串行 HTTP 事务的时间线
与建立 TCP 连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的。
也就是说， HTTP 时延就是由 TCP 网络时延构成的。

HTTP 事务的时延有以下几种主要原因：

1. 客户端首先需要根据 URI 确定 Web 服务器的 IP 地址和端口号。
如果最近没有对 URI 中的主机名进行访问，通过 DNS 解析系统将 URI 中的主机名转换成一个 IP 地址可能要花费数十秒的时间。
> 大多数 HTTP 客户端都有一个小的 DNS 缓存，用来保存近期所访问站点的 IP 地址。如果 已经在本地“缓存”(记录)了 IP 地址，查询就可以立即完成。

2. 接下来，客户端会向服务器发送一条 TCP 连接请求，并等待服务器回送一个请求接受应答。
每条新的 TCP 连接都会有连接建立时延，这个值通常最多只有一两秒钟。
但如果有数百个 HTTP 事务的话，这个值会快速地叠加上去。

3. 因特网传输请求报文，以及服务器处理请求报文都需要时间。
然后，Web 服务器会回送 HTTP 响应，这也需要花费时间。

这些 TCP 网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP 协议的技术复杂性也会对时延产生巨大的影响。

### 4.2.2 性能聚焦区域

以下列出了一些会对 HTTP 程序员产生影响的、最常见的 TCP 相关时延，其中包括:
- TCP 连接建立握手;
- TCP 慢启动拥塞控制;
- 数据聚集的 Nagle 算法;
- 用于捎带确认的 TCP 延迟确认算法;
- TIME_WAIT 时延和端口耗尽。

如果要编写高性能的 HTTP 软件，就应该理解上面的每一个因素。

### 4.2.3 TCP连接的握手时延

建立一条新的 TCP 连接时，甚至是在发送任意数据之前，TCP 软件之间会交换一系列的 IP 分组，对连接的有关参数进行沟通(如下图)。如果连接只用来传送少量数据，这些交换过程就会严重降低 HTTP 的性能。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/414d6b9cb3f1460b865380954d31e13b~tplv-k3u1fbpfcp-watermark.image)

TCP 连接握手需要经过以下几个步骤：

1. 请求新的 TCP 连接时，客户端要向服务器发送一个小的 TCP 分组(通常是 40 ~ 60 个字节)。这个分组中设置了一个特殊的 SYN 标记，说明这是一个连接请求。
2. 如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个 TCP 分组，这个分组中的 SYN 和 ACK 标记都被置位，说明连接请求已被接受。
3. 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立。现代的 TCP 栈都允许客户端在这个确认分组中发送数据。

通常 HTTP 事务都不会交换太多数据，小的 HTTP 事务可能会在 TCP 建立上花费 50%，或更多的时间。
为减小这种 TCP 建立时延所造成的影响的，HTTP 采用了重用现存连接的方式。

### 4.2.4 延迟确认

由于因特网自身无法确保可靠的分组传输(因特网路由器超负荷的话，可以随意丢弃分组)，所以 TCP 实现了自己的确认机制来确保数据的成功传输。

每个 TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。

由于确认报文很小，所以 TCP 允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP 将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多 TCP 栈都实现了一种“延迟确认”算法。延迟确认算法会在一个特定的窗口时间(通常是 100 ~ 200 毫秒)内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。

但是，HTTP 具有双峰特征的请求 - 应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。

在对 TCP 栈的任何参数进行修改之前，一定要对自己在做什么有清醒的认识。TCP 中引入这些算法的目的是防止设计欠佳的应用程序对因特网造成破坏。对 TCP 配置进行的任意修改，都要绝对确保应用程序不会引发这些算法所要避免的问题。

### 4.2.5 TCP慢启动

TCP 数据传输的性能还取决于 TCP 连接的使用期(age)。TCP 连接会随着时间进行 自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移 提高传输的速度。这种调谐被称为 TCP 慢启动(slow start)，用于防止因特网的突然过载和拥塞。

TCP 慢启动限制了一个 TCP 端点在任意时刻可以传输的分组数。简单来说，每成功接收一个分组，发送端就有了发送另外两个分组的权限。如果某个 HTTP 事务有大量数据要发送，是不能一次将所有分组都发送出去的。必须发送一个分组，等待确认;然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组了， 以此类推。这种方式被称为“打开拥塞窗口”。

由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定量数据的、 “已调谐”连接慢一些。由于已调谐连接要更快一些，所以 HTTP 中有一些可以重用现存连接的工具。本章稍后会介绍这些 HTTP“持久连接”。

### 4.2.6 Nagle算法与TCP_NODELAY

TCP 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入 TCP 栈中 —— 即使一次只放一个字节也可以!但是，每个 TCP 段中都至少装载了 40 个字节的标记和首部，所以如果 TCP 发送了大量包含少量数据的分组，网络的性能就会严重下降。

Nagle 算法(根据其发明者 John Nagle 命名)试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。RFC 896“IP/TCP 互连网络中的拥塞控制”对此算法进行了描述。

Nagle 算法鼓励发送全尺寸(LAN 上最大尺寸的分组大约是 1500 字节，在因特网 上是几百字节)的段。只有当所有其他分组都被确认之后，Nagle 算法才允许发送 非全尺寸的分组。如果其他分组仍然在传输过程中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会 将缓存的数据发送出去。

Nagle 算法会引发几种 HTTP 性能问题。首先，小的 HTTP 报文可能无法填满一个 分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle 算法与延迟确认之间的交互存在问题——Nagle 算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟 100 ~ 200 毫秒。

HTTP 应用程序常常会在自己的栈中设置参数 TCP_NODELAY，禁用 Nagle 算法，提高性能。
如果要这么做的话，一定要确保会向 TCP 写入大块的数据，这样就不会产生一堆小分组了。

## 4.3 HTTP连接的处理

### 4.3.1 常被误解的Connection首部

HTTP 允许在客户端和最终的源端服务器之间存在一串 HTTP 中间实体(代理、高速缓存等)。可以从客户端开始，逐跳地将 HTTP 报文经过这些中间设备，转发到源端服务器上去(或者进行反向传输)。

在某些情况下，两个相邻的 HTTP 应用程序会为它们共享的连接应用一组选项。HTTP 的 Connection 首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。

如果 Connection 标签中包含了一个 HTTP 首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。在将报文转发出去之前，必须删除 Connection 首部列出的所有首部字段。由于 Connection 首部可以防止无意中对 本地首部的转发，因此将逐跳首部名放入 Connection 首部被称为“对首部的保护”。
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/585f90bee366475ebc069292d6cacbc6~tplv-k3u1fbpfcp-watermark.image)

Connection 首部可以承载 3 种不同类型的标签:
- HTTP 首部字段名，列出了只与此连接有关的首部; 
- 任意标签值，用于描述此连接的非标准选项;
- 值 close，说明操作完成之后（发送完下一条报文之后）需关闭这条持久连接。

### 4.3.2 串行事务处理时延

如果每个HTTP事务都需要(串行地建立)一条新的连接，那么连接时延和慢启动时延就会叠加起来。
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f5f31ed62c44e21a33ddc50e8247a0f~tplv-k3u1fbpfcp-watermark.image)

串行加载除了引入的实际时延外还会导致在加载了足够多的对象之前，无法在屏幕上显示任何内容，让用户面对一个空白的屏幕，对装载的进度一无所知。

提高 HTTP 的连接性能，现在多采用以下技术：
- **并行连接**
通过多条 TCP 连接发起并发的 HTTP 请求。
- **持久连接**
重用 TCP 连接，以消除连接及关闭时延。
- **管道化连接**
通过共享的 TCP 连接发起并发的 HTTP 请求。
- **复用的连接** 
交替传送请求和响应报文。

## 4.4 并行连接

浏览器可以先完整地请求原始的 HTML 页面，然后请求第一个嵌入对象，然后请求第二个嵌入对象等，以这种简单的方式对每个嵌入式对象进行串行处 理。但这样实在是太慢了!

HTTP 允许客户端打开多条连接，并行地执行多个 HTTP 事务。在下图例子中，并行加载了四幅嵌入式图片，每个事务都有自己的 TCP 连接。
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4212231bbd94f68a3c5bca2f8c2d3db~tplv-k3u1fbpfcp-watermark.image)

### 4.4.1 并行连接可能会提高页面的加载速度

包含嵌入对象的组合页面如果能(通过并行连接)克服单条连接的空载时间和带宽限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcd0f5c0c6f147e6ae984547aab7b488~tplv-k3u1fbpfcp-watermark.image)

### 4.4.2 并行连接不一定更快，只是可能让人“感觉”更快一些

即使并行连接的速度可能会更快，但并不一定总是更快。比如客户端的网络带宽不足时，大部分的时间可能都是用来传送数据的。如果并行加载多个对象，每个对象都会去竞争这有限的带宽，带来的性能提升就很小。
而且，打开大量连接会消耗很多内存资源，从而引发性能问题。

实际上，浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小的值(不同浏览器不同版本各有差异，当前chrome是6个)。
服务器可以随意关闭来自特定客户端的超量连接。

并行连接并没有加快页面的传输速度，但因为多个组件对象同时出现在屏幕上时，用户能够看到加载的进展。
如果整个屏幕上有很多动作在进行，即使实际上秒表显示整个页面的下载时间更长，人们也会认为 Web 页面加载得更快一些。

## 4.5 持久连接

一个 Web 页面上的大部分内容，通常都来自某几个 Web 站点，初始化了对某服务器 HTTP 请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求。
因此，HTTP/1.1(以及 HTTP/1.0 的各种增强版本)允许 HTTP 设备在事务处理结束之后将 TCP 连接保持在打开状态，以便为未来的 HTTP 请求重用现存的连接。
在事务处理结束之后仍然保持在打开状态的 TCP 连接被称为持久连接。
非持久连接会在 每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。

重用已对目标服务器打开的空闲持久连接：
1. 就可以避开缓慢的连接建立阶段；
2. 已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。

### 4.5.1 持久以及并行连接

我们看到，并行连接可以提高复合页面的传输速度。但并行连接也有一些缺点。
- 每个事务都会打开 / 关闭一条新的连接，会耗费时间和带宽。
- 由于 TCP 慢启动特性的存在，每条新连接的性能都会有所降低。 
- 可打开的并行连接数量实际上是有限的。

持久连接有一些比并行连接更好的地方。
持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。
但是，管理持久连接时要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。

持久连接与并行连接配合使用可能是最高效的方式。
现在，很多 Web 应用程序都会打开少量的并行连接，其中的每一个都是持久连接。持久连接有两种类型:
比较老的 HTTP/1.0+“keep-alive”连接，以及现代的 HTTP/1.1“persistent”连接。
在接下来的几节中我们将对这两种类型进行介绍。

### 4.5.2 HTTP/1.0+ keep-alive连接

keep-alive 连接的一些性能优点，图中将在串行连接上实现 4 个 HTTP 事务的时间线与在一条持久连接上实现同样事务所需的时间线进行了比较。 由于去除了进行连接和关闭连接的开销，所以时间线有所缩减。
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a8cb46bc26341818c67a3f3fca4b381~tplv-k3u1fbpfcp-watermark.image)

### 4.5.3 Keep-Alive操作

实现 HTTP/1.0 keep-alive 连接的客户端可以通过包含 Connection: Keep-Alive 首部请求将一条连接保持在打开状态。
如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部。
如果响应中没有 Connection: Keep-Alive 首部，客户端就认为服务器不支持 keep-alive，会在发回响应报文之后关闭连接。
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3737acde692046a7a09de966e05556f8~tplv-k3u1fbpfcp-watermark.image)

### 4.5.4 Keep-Alive选项

keep-Alive 首部只是请求将连接保持在活跃状态。
发出 keep-alive 请求之后，客户端和服务器并不一定会同意进行 keep-alive 会话。
它们可以在任意时刻关闭空闲的 keep-alive 连接，并可随意限制 keep-alive 连接所处理事务的数量。

可以用 Keep-Alive 通用首部中指定的、由逗号分隔的选项来调节 keep-alive 的行为。
- 参数 timeout 是在 Keep-Alive 响应首部发送的。它估计了服务器希望将连接 保持在活跃状态的时间。这并不是一个承诺值。
- 参数 max 是在 Keep-Alive 响应首部发送的。它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。
- Keep-Alive首部还可支持任意未经处理的属性，这些属性主要用于诊断和调试。 语法为```name [=value]```。

Keep-Alive 首部完全是可选的，但只有在提供 Connection: Keep-Alive 时才能 使用它。
```js
Connection: Keep-Alive  // 启用持久连接
Keep-Alive: max=5, timeout=120  // 服务器最多会为另外五个事务保持连接。或者保持2min
```

### 4.5.5 Keep-Alive连接的限制和规则

使用 keep-alive 连接时有一些限制和一些需要澄清的地方。
- 在HTTP/1.0中，keep-alive并不是默认使用的。客户端必须发送一个 Connection: Keep-Alive 请求首部来激活 keep-alive 连接。
- Connection: Keep-Alive 首部必须随所有希望保持持久连接的报文一起发送。如果客户端没有发送 Connection: Keep-Alive 首部，服务器就会在那条请求 之后关闭连接。
- 通过检测响应中是否包含 Connection: Keep-Alive 响应首部，客户端可以判断服务器是否会在发出响应之后关闭连接。
- 只有在无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能将连接保持在打开状态——也就是说实体的主体部分必须有正确的 Content-Length，有多部件媒体类型，或者用分块传输编码的方式进行了编码。在一条 keep-alive 信道中回送错误的 Content-Length 是很糟糕的事，这样的话，事务 处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始了。
- 代理和网关必须执行 Connection 首部的规则。代理或网关必须在将报文转发出 去或将其高速缓存之前，删除在 Connection 首部中命名的所有首部字段以及 Connection 首部自身。
- 严格来说，不应该与无法确定是否支持 Connection 首部的代理服务器建立 keep-alive 连接，以防止出现下面要介绍的哑代理问题。在实际应用中不是总能做到这一点的。
- 从技术上来讲，应该忽略所有来自 HTTP/1.0 设备的 Connection 首部字段(包括 Connection: Keep-Alive)，因为它们可能是由比较老的代理服务器误转发的。但实际上，尽管可能会有在老代理上挂起的危险，有些客户端和服务器还是 会违反这条规则。
- 除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之 前连接就关闭了，客户端就一定要做好重试请求的准备。

### 4.5.6 Keep-Alive和哑代理

- **Connection首部和盲中继**

  那些不理解 Connection 首部，而且不知道在沿着转发链路将其发送出去之前，应该将该首部删除的代理会成为盲中继(blind relay)，它们只是将字节从一个连接转发到另一个连接中去，不对 Connection 首部进行特殊的处理。
  ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd9862e8879a4568b745676572b620ae~tplv-k3u1fbpfcp-watermark.image)

  经过中继的 HTTP 请求抵达了 Web 服务器。当 Web 服务器收到 经过代理转发的 Connection: Keep-Alive 首部时，会误以为代理(对服务器 来说，这个代理看起来就和所有其他客户端一样)希望进行 keep-alive 对话!对 Web 服务器来说这没什么问题——它同意进行 keep-alive 对话，并在图 4-15c 中 回送了一个 Connection: Keep-Alive 响应首部。所以，此时 Web 服务器认为它在与代理进行 keep-alive 对话，会遵循 keep-alive 的规则。但代理却对 keep-alive 一无所知。

  同理，此时客户端和服务器都认为 它们在进行 keep-alive 对话，但与它们进行对话的代理却对 keep-alive 一无所知。

  由于代理对 keep-alive 一无所知，所以会将收到的所有数据都回送给客户端，然 后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接 保持在打开状态了，所以不会去关闭连接。这样，代理就会挂在那里等待连接的关闭。

  客户端在上图d线 中收到了回送的响应报文时，会立即转向下一条请求，在 keep-alive 连接上向代理发送另一条请求(参见上图e线)。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了。

  这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接 超时，并将其关闭为止。

- **代理和逐跳首部**

  为避免此类代理通信问题的发生，现代的代理都绝不能转发 Connection 首部 和所有名字出现在 Connection 值中的首部。因此，如果一个代理收到了一个 Connection: Keep-Alive 首部，是不应该转发 Connection 首部，或所有名为 Keep-Alive 的首部的。

  另外，还有几个不能作为 Connection 首部值列出，也不能被代理转发或作为 缓 存 响 应 使 用 的 首 部。 其 中 包 括 Proxy-Authenticate、Proxy-Connection、 Transfer-Encoding 和 Upgrade。

  浏览器会向代理发送非标准的 Proxy-Connection 扩展首部，而不是官方支持的著名的 Connection 首部。如果代理是盲中继，它会将无意 义的 Proxy-Connection 首部转发给 Web 服务器，服务器会忽略此首部，不会带 来任何问题。但如果代理是个聪明的代理(能够理解持久连接的握手动作)，就用一 个 Connection 首部取代无意义的 Proxy-Connection 首部，然后将其发送给服务器，以收到预期的效果。

  在客户端和服务器之间只有一个代理时可以用这种方案来解决问题。如果在哑代理的任意一侧还有一个聪明的代理，这个问题就会再次露头了。
  
## 管道化连接

## 关闭连接的奥秘
