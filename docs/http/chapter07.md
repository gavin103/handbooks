---
title: 第七章：缓存
date: 2021-01-20
---
[[TOC]]

Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这 个文档。使用缓存有下列优点。

- 缓存减少了冗余的数据传输，节省了你的网络费用。
- 缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。
- 缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。 
- 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。

## 7.1 冗余的数据传输

有很多客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档， 每次传送给一个客户端。
这些冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，加重 Web 服务器的负载。
缓存可以保留第一条服务器响应的副本，后继请求就可以由缓存的副本来应对

## 7.2 带宽瓶颈

由于短板效应，客户端会以访问路径上最慢的网速访问服务器。
如果客户端从一个快速局域网的缓存中得到了一份副本，就大大提高了性能。

## 7.3 瞬间拥塞

突发事件比如热点新闻，秒杀活动会造成流量峰值，瞬间拥塞网络，让和 Web 服务器产生灾难性的崩溃。

## 7.4 距离时延

每台网络设备都会造成时延，距离越长，访问路径上节点越多，时延就越明显。
将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米。

## 7.5 命中和未命中的

可以用已有的副本为某些到达缓存的请求提供服务。这被称为缓存命中(cache hit)。
其他一些到达缓存的请求可能会由于没有副本可用，而被转发 给原始服务器。这被称为缓存未命中(cache miss)
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40884016e82e48bbb85fec509773e1c7~tplv-k3u1fbpfcp-watermark.image)

### 7.5.1 再验证

原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本。这些“新鲜度检测”被称为 HTTP 再验证 (revalidation)。

为了节省带宽，大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行再验证。

缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果 内容没有变化，服务器会以一个小的 304 Not Modified 进行响应。只要缓存知道副 本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端这被称作再验证命中(revalidate hit)或缓慢命中(slow hit)。这种方式确实 要与原始服务器进行核对，所以会比单纯的缓存命中要慢，但它没有从服务器中获取对象数据，所以要比缓存未命中快一些。

HTTP 为我们提供了几个用来对已缓存对象进行再验证的工具，但最常用的是 If- Modified-Since 首部。将这个首部添加到 GET 请求中去，就可以告诉服务器，只 有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。

- 再验证命中

如果服务器对象未被修改，服务器会向客户端发送一个小的 HTTP 304 Not Modified 响应。

- 再验证未命中 

如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整 内容的 HTTP 200 OK 响应。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f0f953693a742a2843a6d21464870fe~tplv-k3u1fbpfcp-watermark.image)

- 对象被删除

如果服务器对象已经被删除了，服务器就回送一个 404 Not Found 响应，缓存也 会将其副本删除。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04872bb5790d486db02a5d3d00f6d3f9~tplv-k3u1fbpfcp-watermark.image)

### 7.5.2 命中率

由缓存提供服务的请求所占的比例被称为缓存命中率(cache hit rate，或称为缓存命中比例)

### 7.5.3 字节命中率

文档体积有大小，所以文档命中率不能说明一切，有些人更愿意使用字节命中率(byte hit rate)作为度量值：
字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。

文档命中率和字节命中率对缓存性能的评估都是很有用的。文档命中率说明阻止了 多少通往外部网络的 Web 事务。
提高文档命中率对降低整体延迟(时延)很有好处。
字节命中率说明阻止了多少字节传向因特网。提高字节命中率对节省带宽很有利。

### 7.5.4 区分命中和未命中的情况

HTTP 没有为用户提供一种手段来区分响应是缓存命中的，还是访问原 始服务器得到的。
在这两种情况下，响应码都是 200 OK，说明响应有主体部分。
(这里容易混淆一个概念，缓存设备响应给客户端的请求，响应码也是200。与客户端自身的缓存做区分)

客户端有一种方法可以判断响应是否来自缓存，就是使用 Date 首部。将响应中 Date 首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存的响应。
客户端也可以通过 Age 首部来检测缓存的响应，通过这个首部可以分辨出这条响应的使用期。

## 7.6 缓存的拓扑结构

### 7.6.1 私有缓存

私有缓存不需要很大的动力或存储空间，这样就可以将其做得很小，很便宜。Web 浏 览器中有内建的私有缓存 —— 大多数浏览器都会将常用文档缓存在你个人电脑的磁盘 和内存中，并且允许用户去配置缓存的大小和各种设置。

### 7.6.2 公有代理缓存

公有缓存是特殊的共享代理服务器，被称为缓存代理服务器(caching proxy server)，或者更常见地被称为代理缓存(proxy cache)。

公有缓存会接受来自多个 用户的访问，所以通过它可以更好地减少冗余流量。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84c72d1cb1f543f6a904a79f0fa74af3~tplv-k3u1fbpfcp-watermark.image)

### 7.6.3 代理缓存的层次结构

实现层次化(hierarchy)的缓存是很有意义的。
在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享的文档。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b24f4297c864b53a6bbfd8d8f5d42c3~tplv-k3u1fbpfcp-watermark.image)

我们希望大部分用户都能在附近的第一级缓存中命中，当代理链路变得很长的时候，这种性能损耗会变得非常明显。

### 7.6.4 网状缓存、内容路由以及对等缓存

有些网络结构会构建复杂的网状缓存(cache mesh)，而不是简单的缓存层次结构。
网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决 策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。 
这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为 内容路由器(content router)

HTTP 并不支持兄弟缓存，所以人们通过一些协议对 HTTP 进行了扩展，比如因特网缓存协议(Internet Cache Protocol，ICP)和超文本缓存协 议(HyperText Caching Protocol，HTCP)。
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1374628fcd24cb5bd6626937a0860da~tplv-k3u1fbpfcp-watermark.image)

## 7.7 缓存的处理步骤

Web 缓存的基本工作 原理大多很简单。对一条 HTTP GET 报文的基本缓存处理过程包括 7 个步骤:
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc6af4c2a6c34ecabf788a57266cfcc9~tplv-k3u1fbpfcp-watermark.image)
1. **接收**——
缓存从网络中读取抵达的请求报文。
高性能的缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理。

2. **解析**——
缓存对报文进行解析，提取出 URL 和各种首部，并做修改。

3. **查询**——
缓存查看是否有本地副本可用，如果没有，它可以根据情形和配置，到原始服务器 或父代理中去取（并将其保存在本地），或者返回一条错误信息。
已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中 时返回正确的服务器首部。
已缓存对象中还包含了一些元数据(metadata)，用来记 录对象在缓存中停留了多长时间，以及它被用过多少次等。

4. **新鲜度检测**——
缓存查看已缓存副本是否在新鲜度限值(freshness limit)内，如果不是，就询问服务器是否有任何更新。

5. **创建响应**——
缓存会用新的首部和已缓存的主体来构建一条响应报文。
缓存负责对这些首部进行改造，以便与客户端的要求相匹配。改造内容可能包含因协议不同带来的首部转换。
通常会包含一 个 Via 首部来说明请求是由一个代理缓存提供的。
缓存不应该调整 Date 首部。Date 首部表示的是原始服务器最初产生这个对 象的日期。

6. **发送**——
缓存通过网络将响应发回给客户端。
高性能的缓存会尽力高效地发送数据，通常可 以避免在本地缓存和网络 I/O 缓冲区之间进行文档内容的复制。

7. **日志**——
大多数缓存都会保存日志文件以及与缓存的使用有关的一些统计数据。
每个缓存事 务结束之后，缓存都会更新缓存命中和未命中数目的统计数据(以及其他相关的度 量值)，并将条目插入一个用来显示请求类型、URL 和所发生事件的日志文件。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d46938f475f4f6eb478b6f1b51b2a84~tplv-k3u1fbpfcp-watermark.image)

##  7.8 保持副本的新鲜

HTTP 有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP 将这些简单的机制称为 文档过期(document expiration)和服务器再验证(server revalidation)。

### 7.8.1 文档过期

通过特殊的 HTTP Cache-Control 首部和 Expires 首部，HTTP 让原始服务器向每个文档附加了一个“过期日期”。
一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果 被修改过，就要获取一份新鲜(带有新的过期日期)的副本。

### 7.8.2 过期日期和使用期

服务器用 HTTP/1.0+ 的 Expires 首部或 HTTP/1.1 的 Cache-Control: max-age 响应首 部来指定过期日期，同时还会带有响应主体。Expires 首部和 Cache-Control: max-age 首部所做的事情本质上是一样的，但由于 Cache-Control 首部使用的是 相对时间而不是绝对日期，所以我们更倾向于使用比较新的 Cache-Control 首部。 绝对日期依赖于计算机时钟的正确设置。

### 7.8.3 服务器再验证

仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际的区别;这只是意味着到了要进行核对的时间了。这种情况被称为“服务器再 验证”，说明缓存需要询问原始服务器文档是否发生了变化。

- 如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在 旧文档的位置上，然后将文档发送给客户端。
- 如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过 期日期，并对缓存中的首部进行更新就行了。

### 7.8.4 用条件方法进行再验证

HTTP 的条件方法可以高效地实现再验证。HTTP 允许缓存向原始服务器发送一个 “条件 GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主 体。通过这种方式，将新鲜度检测和对象获取结合成了单个条件 GET。向 GET 请 求报文中添加一些特殊的条件首部，就可以发起条件 GET。只有条件为真时，Web 服务器才会返回对象。

HTTP 定义了 5 个条件请求首部。对缓存再验证来说最有用的 2 个首部是 If- Modified-Since 和 If-None-Match。

- **If-Modified-Since:date**

如果从指定日期之后文档被修改过了，就执行请求的方法。可以与 Last-Modified 服务器响应首部配合使用，只有在内容被修改后与已 缓存版本有所不同的时候才去获取内容

- **If-None-Match:tags**
服务器可以为文档提供特殊的标签(参见 ETag)，而不是将其与最近修 改日期相匹配，这些标签就像序列号一样。如果已缓存标签与服务器文 档中的标签有所不同，If-None-Match 首部就会执行所请求的方法

### 7.8.5 If-Modified-Since:Date再验证

If-Modified-Since 再验证请 求通常被称为 IMS 请求。

- 如果自指定日期后，文档被修改了，If-Modified-Since 条件就为真，通常 GET 就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信 息之外，还包含了一个新的过期日期。

- 如果自指定日期后，文档没被修改过，条件就为假，会向客户端返回一个小 的 304 Not Modified 响应报文，为了提高有效性，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如， Content-Type 首部通常不会被修改，所以通常不需要发送。一般会发送一个 新的过期日期。

If-Modified-Since 首部可以与 Last-Modified 服务器响应首部配合工作。原始 服务器会将最后的修改日期附加到所提供的文档上去。当缓存要对已缓存文档进行 再验证时，就会包含一个 If-Modified-Since 首部，其中携带有最后修改已缓存副 本的日期:
``` If-Modified-Since: <cached last-modified date> ```

如果在此期间内容被修改了，最后的修改日期就会有所不同，原始服务器就会回送 新的文档。否则，服务器会注意到缓存的最后修改日期与服务器文档当前的最后修 改日期相符，会返回一个 304 Not Modified 响应。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ad1df94e904161adfc852faf2c996a~tplv-k3u1fbpfcp-watermark.image)

### 7.8.6 If-None-Match:实体标签再验证

有些情况下仅使用最后修改日期进行再验证是不够的。

- 有些文档可能会被周期性地重写(比如，从一个后台进程中写入)，但实际包含 的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。
- 有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重 装数据(比如对拼写或注释的修改)。
- 有些服务器无法准确地判定其页面的最后修改日期。
- 有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。

为了解决这些问题，HTTP 允许用户对被称为实体标签(ETag)的“版本标识符” 进行比较。实体标签是附加到文档上的任意标签(引用字符串)。它们可能包含了文 档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。

当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样， 如果实体标签被修改了，缓存就可以用 If-None-Match 条件首部来 GET 文档的新 副本了。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff5931076cc941a4a7a0253fd12f56b5~tplv-k3u1fbpfcp-watermark.image)

可以在 If-None-Match 首部包含几个实体标签，告诉服务器，缓存中已经存在带有这些实体标签的对象副本:

```js
If-None-Match: "v2.6"
If-None-Match: "v2.4","v2.5","v2.6"
If-None-Match: "foobar","A34FAC0095","Profiles in Courage"
```

### 7.8.7 强弱验证器

实体标签和最近修改日期都是缓存验证 器(cache validator)。

HTTP/1.1 支持“弱验证器”，如果只对内容进行了少量修改，就 允许服务器声明那是“足够好”的等价体。

只要内容发生了变化，强验证器就会变化。弱验证器允许对一些内容进行修改，但 内容的主要含义发生变化时，通常它还是会变化的。

服务器会用前缀“W/”来标识弱验证器。

```js
ETag: W/"v2.6" 
If-None-Match: W/"v2.6"
```

### 7.8.8 什么时候应该使用实体标签和最近修改日期

如果服务器回送了一个实体标签，HTTP/1.1 客户端就必须使用实体标签验证器。如果服务器只回送了一个 Last-Modified 值，客户端就可以使用 If-Modified-Since 验证。如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案，这样 HTTP/1.0 和 HTTP/1.1 缓存就都可以正确响应了。

## 7.9 控制缓存的能力

服务器可以通过 HTTP 定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，服务器可以:

- 附加一个 Cache-Control: no-store 首部到响应中去;
- 附加一个 Cache-Control: no-cache 首部到响应中去;
- 附加一个 Cache-Control: must-revalidate 首部到响应中去;
- 附加一个 Cache-Control: max-age 首部到响应中去;
- 附加一个 Expires 日期首部到响应中去;
- 不附加过期信息，让缓存确定自己的过期日期。

### 7.9.1 no-Store与no-Cache响应首部

HTTP/1.1 提供了几种限制对象缓存，或限制提供已缓存对象的方式，以维持对象的新鲜度。
```js
Pragma: no-cache 
Cache-Control: no-store 
Cache-Control: no-cache
```

标识为 no-store 的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服 务器一样，向客户端转发一条 no-store 响应，然后删除对象。

标识为 no-cache 的响应实际上是可以存储在本地缓存区中的。只是在与原始服 务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。

### 7.9.2 max-age响应首部

Cache-Control: max-age 首部表示的是从服务器将文档传来之时起，可以认为此 文档处于新鲜状态的秒数。还有一个 s-maxage 首部(注意 maxage 的中间没有连 字符)，其行为与 max-age 类似，但仅适用于共享(公有)缓存:
```js
Cache-Control: max-age=3600 
Cache-Control: s-maxage=3600
```
服务器可以请求缓存不要缓存文档，或者将最大使用期设置为零，从而在每次访问 的时候都进行刷新:

### 7.9.3 Expires响应首部

不推荐使用 Expires 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者 后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒 数，而不是绝对时间来表示过期时间。

### 7.9.4 must-revalidate响应首部

Cache-Control: must-revalidate 响应首部告诉缓存，在事先没有跟原始服务 器进行再验证的情况下，不能提供这个对象的陈旧副本。缓存仍然可以随意提供新 鲜的副本。如果在缓存进行 must-revalidate 新鲜度检查时，原始服务器不可用，缓存就必须返回一条 504 Gateway Timeout 错误。

### 7.9.5 试探性过期

如果响应中没有 Cache-Control: max-age 首部，也没有 Expires 首部，缓存可 以计算出一个试探性最大使用期。

LM-Factor 算法是一种很常用的试探性过期算法

### 7.9.6 客户端的新鲜度限制

Web 浏览器都有 Refresh(刷新)或 Reload(重载)按钮，可以强制对浏览器或 代理缓存中可能过期的内容进行刷新。Refresh 按钮会发布一个附加了 Cache- Control 请求首部的 GET 请求，这个请求会强制进行再验证，或者无条件地从服 务器获取文档。Refresh 的确切行为取决于特定的浏览器、文档以及拦截缓存的配置。
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba94b45795d140b19bd700b3b0d37620~tplv-k3u1fbpfcp-watermark.image)

### 7.9.7 注意事项
如果发布者不小心分配了一个很久之后的过期日期，在文档过期之前，她要对文档做的任何修改都不一定能显示在所有缓存中。
因此，很多发布者都不会使用很长的过期日期。而且，很多发布者甚至都不使用过 期日期，这样缓存就很难确定文档会在多长时间内保持新鲜了。